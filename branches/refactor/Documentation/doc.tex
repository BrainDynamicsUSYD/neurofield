\documentclass[12pt,a4paper]{article} 

\title{NeuroField Reference}
\author{Peter Drysdale \and Felix Fung \and Romesh Abeysuriya}
\date{\today}

\usepackage[latin1]{inputenc}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

\usepackage{listings}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[top=2cm,bottom=2cm,left=1.3cm,right=1.3cm]{geometry}
\usepackage{multirow}
\usepackage{amsmath}

\pagestyle{plain}
\parindent=0.0cm
\parskip=0.5cm

\footskip=1.3cm

\lstset{
basicstyle=\small\small\ttfamily,
frame=single,	        % adds a frame around the code
breaklines=true,		% sets automatic line breaking
breakatwhitespace=tru,	% sets if automatic breaks should only happen at whitespace
}
\newcommand{\code}[1]{ 
\begin{lstlisting}
#1
\end{lstlisting}
}
\newcommand{\type}[1]{ {\small\small\tt #1} }

\begin{document}

\maketitle
\abstract{\type{NeuroField} is a computer program (accompanied with helper scripts) that solves the neural field model of Robinson et al. This document is a reference of \type{NeuroField} for both users and developers.}
\tableofcontents

\pagebreak
\section{Users guide}

\type{NeuroField}, initially written by Peter Drysdale, is a \type{C++} program (accompanied with helper scripts) that solves the neural field model of Robinson et al.:
\begin{align*}
	D_{ab}V_{ab}(\mathbf{r},t) &= \nu_{ab}\phi_{ab}(\mathbf{r},t),\\
			Q_a(\mathbf{r},t) &= S_a \big[\sum_b V_{ab}(\mathbf{r},t) \big],\\
	\mathcal{D}_{ab}\phi_{ab}(\mathbf{r},t) &= Q_b(\mathbf{r},t-\tau_{ab}).
\end{align*}
\type{NeuroField} generalizes the neural field theory by allowing users to:
\begin{enumerate}
	\item Specify an arbitrary number of populations and connections between populations;
	\item Specify the parameters for any objects, including populations, dendritic responses, firing responses, propagators, synapses, and stimulus pattern;
	\item Choose alternative wave propagation types, i.e. choose different forms of \(\mathcal{D}_{ab}\);
	\item Uses plastic synapses, i.e. \(\nu_{ab}=\nu_{ab}(\mathbf{r},t)\).
\end{enumerate}

This users guide covers the obtaining, setting up, configuring and launching of \type{NeuroField}.

\subsection{Licensing issues}

\subsection{Obtaining and setting up NeuroField}
The code for NeuroField is managed by a version control system called `subversion'. This stores the entire history of the program, as well as providing a single place to obtain the latest copy of the code. 

In order to use the repository, you will first need an account. This is separate to your Physics login, you will need to contact Romesh Abeysuriya (r.abeysuriya@physics.usyd.edu.au) or Sue Yang (xue.yang@sydney.edu.au) in order to obtain access. 

Once you have done this, log into a computer in the School of Physics, and open a terminal by right clicking on the desktop and selecting `Create Terminal'. Enter the following command into the terminal window:
	
	\begin{lstlisting}
svn co http://silliac.physics.usyd.edu.au:18080/svn/neurofield/trunk neurofield --username=<your SVN username>
	\end{lstlisting}


This will copy the latest version of program from the School of Physics server into the current directory of your terminal (typically your home directory).

You can also use these steps to obtain a copy of NeuroField from a computer which is not connected to the School of Physics network (eg. personal laptops at home). You will require a version of SVN higher than 1.6. However, you will need to have your IP address/network domain registered for remote access, please contact Sebastian Juraszek to request this (ideally by logging a helpdesk request at [http://physics.usyd.edu.au/itsupport] - only available within the School of Physics). 

\subsection{Directory layout}
Within the main directory, the user can find:

\begin{tabular}{l p{12cm}}
\type{*.h, *.cpp}& C++ source code.\\
\type{Configs/}& Stores configuration files for \type{NeuroField}.\\
\type{Documentation/}& \type{Documentation/doc.tex} is the \LaTeX\ file for generating this document. Running \type{make doc} produces this document in \type{pdf} format, and \type{make clean} removes all the files \LaTeX\ produced (including \type{doc.pdf} and excluding \type{doc.tex}).\\
\type{helper\_scripts/}& Stores helper scripts, including plotting routines and other post-processing of data procedures.\\
\type{Launch}& A launcher script that handles compilation and launching of \type{NeuroField}, capable of automating parameter sweeps and submitting jobs in \type{yossarian}.\\
\type{Output/}& When using the launcher script to sweep over parameters, the launcher script produces this directory, which stores all output files \type{neurofield.*} in independent subdirectories.\\
\type{Release/}& All compiled files, including the object files and the \type{NeuroField} executable is stored here. This directory will be deleted by \type{make clean}, so user data should not be stored here.\\
\type{neurofield.*}& Output files of \type{NeuroField}.
\end{tabular}

\subsection{Using NeuroField via launcher script}

\begin{enumerate}

\item Edit \type{Makefile}: Identify the platform to run NeuroField, and comment/uncomment the appropriate \type{COMP} directions. Generally, this step is not needed, but users are encouraged to check.

\item To execute with only one set of parameters, edit your configuration file in \type{./Configs}, then run
\begin{lstlisting}
./Launch Configs/config_file
\end{lstlisting}
For example,
\begin{lstlisting}
./Launch Configs/cortex.conf
\end{lstlisting}
The output will be stored in the current directory.\footnote{Tips for \type{vi} users: you can launch \type{NeuroField} in \type{vi} with \type{:!./Launch \% [optional params]} }

\item To ease parameter exploration, the launcher script is capable of doing parameter sweeps. The launcher script supports sweeping over an arbitrary number of objects, parameters and runs. For example, if the user wants to launch \type{NeuroField} 3 times, with parameters varying according to the following table,

\begin{tabular}{l l r r r}
Object(s)&Parameter&1\textsuperscript{st} run&2\textsuperscript{nd} run&3\textsuperscript{rd} run\\
\hline
\type{Propag 1}, \type{Propag 2}&\type{gamma}&10&20&30\\
\type{Couple 1}&\type{nu}&1&2&3
\end{tabular}

simply list the above table entries into the argument list:
\begin{lstlisting}
./Launch Configs/cortex.conf 'Propag 1' 'Propag 2' gamma 10 20 30 'Couple 1' nu 1 2 3
\end{lstlisting}

In terms of syntactic restriction, each row in the table can have an arbitary number of objects, but only one parameter; every row must have the same number of runs.

\item In case the script is executed on \type{yossarian}, the launcher script tries to find a file called \type{pbs}. If no such file is found, the user would be prompted for a job name, expected computational time and email to generate \type{pbs}. This file is then submitted to the PBS system.

\item To clean up the directory, delete or store your \type{neurofield.*} output files and the \type{Output/} directory and subdirectories. Then run
\begin{lstlisting}
make clean
\end{lstlisting}
to delete \type{./Release/} and the files \LaTeX produced in \type{Documentation/}.

\item This documentation can be generated by running 
\begin{lstlisting}
make doc
\end{lstlisting}
which produces \type{./Document\-ation.pdf}. \type{make clean} deletes the files (including \type{./Document\-ation.pdf}) created by \LaTeX.

\end{enumerate}

\subsection{Using NeuroField executable without launcher script}
\label{sec:exe}

It is possible to use the launcher script in virtually all cases, so that a user may skip this section. A notable exception is to restart a completed simulation with a \type{neurofield.dump} file. If a user wishes to use the \type{./Release/NeuroField} executable without the launcher script, then compile it by running
\begin{lstlisting}
make
\end{lstlisting}
The \type{NeuroField} executable and object files are produced in \type{./Release/}.

The \type{./Release/NeuroField} executable runs in one of two modes, initial run mode and restart mode.

(1) In inital run mode \type{NeuroField} takes input from an \type{neurofield.conf} file initializes the simulation and then takes specified number of integration steps writing out a \type{neurofield.output} file and a \type{neurofield.dump} file for restarting.  The input filename can be changed on the command line by using the switch \type{-i newinputfilename}. Similarly the name of the output filename which defaults to \type{neurofield.output} can be changed via the switch \type{-o newoutputfilename}. The dump file which defaults to \type{neurofiled.dump} can be changed via \type{-d newdumpfilename}.

(2) The code dumps sufficient data about parameter values to restart. In restart mode the simulation will continue where it left off. Restart mode is accessed by running the code with command \type{Neurofield restart} rather than the usual \type{Neurofield} command on the command line. In order to run the code in restart mode it is necessary to take the \type{neurofield.dump} file which was produced from the run which will be restarted to be renamed as the new \type{neurofield.conf} file. The new \type{neurofield.conf} file should also be changed to reflect the new number of timesteps etc.  Note:- A restarting \type{neurofield.conf} file has different content to an initial run \type{neurofield.conf} and can only be used in restart mode.

A brief description is given by
\begin{lstlisting}
./Release/NeuroField --help
\end{lstlisting}

\subsection{Writing a configuration file}

\type{NeuroField} allows an arbitrary number of populations and connections between them, with all objects taking arbitrary parameter values. These are all configured via a configuration file. This section documents the specifications of configuration files, where we use \type{Configs/cortex.conf} as an illustrative example.

To write a configuration file, a user can follow these steps:
\begin{enumerate}
\item Determine your population model by drawing a schematic diagram, thereby constructing a connection matrix. An example is shown in Fig.~\ref{fig:pop}.
\item Look up existing configuration files in \type{Configs/}. By checking the comment located at the top of a configuration file, and also the connection matrix, a user should find the most suitable existing file to construct his own. This is less tedious (and less error prone) than writing a new one from scratch.
\item Specify the global parameters and connectivity matrix (Sec.~\ref{sec:global}).
\item Specify all populations (Sec.~\ref{sec:pop}).
\item Specify all propagators (Sec.~\ref{sec:prop}).
\item Specify all couples (Sec.~\ref{sec:couple}).
\item Specify all output requests (Sec.~\ref{sec:output}).
\end{enumerate}

\begin{figure}[h!]\begin{center}
\tikzstyle{block} = [draw,text width=3em,text centered,minimum height=2em]
\tikzstyle{line} = [draw, -latex']
    
\begin{tikzpicture}[node distance = 3em, auto]
	\node[block] (epsilon) {$\epsilon$};
	\node[right of=epsilon,node distance=4em](epsilone){};
	\path[line](epsilon)--(epsilone);
	\node[block, right of=epsilone] (e) {e};
	\path[line] (epsilon) -- (e);

	\node[right of=e](re){};
	\draw(e)--(re);
	\node[above of=re](are){};
	\draw(re)--(are);
	\node[left of=are](ae){};
	\draw(are)--(ae);
	\path[line] (ae) -| (e);

	\node[block, below of=epsilon] (iota) {$\iota$};
	\node[right of=iota,node distance=4em](iotai){};
	\path[line](iota)--(iotai);
	\node[block, right of=iotai] (i) {i};
	\path[line] (iota) -- (i);

	\node[right of=i](ri){};
	\draw(i)--(ri);
	\node[below of=ri](bri){};
	\draw(ri)--(bri);
	\node[left of=bri](bi){};
	\draw(bri)--(bi);
	\path[line] (bi) -| (i);

	\path[line] (e) -- (i);
	\path[line] (iotai) -- (epsilone);
\end{tikzpicture}
\hspace{3cm}\begin{tabular}{ l l l l l }
	From:& $\epsilon$ & $\iota$ & e & i \\
	To $\epsilon$:& 0 & 0 & 0 & 0 \\
	To $\iota$:& 0 & 0 & 0 & 0 \\
	To e:& 1 & 0 & 2 & 3 \\
	To i:& 0 & 4 & 5 & 6
\end{tabular}
\caption{Left: schematic diagram of a purely cortical population model comprising excitatory and inhibitory populations, as well as two stimulus populations; each arrow indicates a connection between populations, so that each stimulus connects to a cortical population, and each cortical population connects to all cortical populations. Right: connection matrix indicating the connections between populations; zero indicates no connection, and a connection is indicated by a nonzero number, ordered top to bottom, left to right.}
\label{fig:pop}\end{center}\end{figure}


\begin{figure}\begin{center}
	\begin{lstlisting}
Purely cortical model with excitatory and inhibitory neurons
Integration steps: 10000 Deltat: .0001 
Nodes: 4
Glutamate dynamics - Lambda: 3e-4 tGlu: 5e-3

Connection matrix:
From: 1 2 3 4
To 1: 0 0 0 0
To 2: 0 0 0 0
To 3: 1 0 2 3
To 4: 0 4 5 6

Population 1: Stimulation
 Stimulus: Mode: Const - Onset: 0.0002 Mean: 5

Population 2: Stimulation
 Stimulus: Mode: Const - Onset: 0.0002 Mean: 5

Population 3: Excitatory neurons
 Q: 8.87145
 Firing: Sigmoid - Theta: 0.013 Sigma: 0.0038 Qmax: 340.0
  Dendrite 1: V: 0.0 alpha: 83 beta: 769
  Dendrite 2: V: Steady alpha: 83 beta: 769
  Dendrite 3: V: Steady alpha: 83 beta: 769

Population 4: Inhibitory neurons
 Q: 8.87145
 Firing: Sigmoid - Theta: 0.013 Sigma: 0.0038 Qmax: 340.0
  Dendrite 4: V: 0.0 alpha: 83 beta: 769
  Dendrite 5: V: Steady alpha: 83 beta: 769
  Dendrite 6: V: Steady alpha: 83 beta: 769

Propag 1: Map - Tau: 0
Propag 2: Map - Tau: 0
Propag 3: Wave - phi: Steady Deltax: 0.0035 Tau: 0 Range: 0.08 gamma: 116
Propag 4: Wave - phi: Steady Deltax: 0.0035 Tau: 0 Range: 0.08 gamma: 116
Propag 5: Map - Tau: 0
Propag 6: Map - Tau: 0
Couple 1: Map - nu: 0.00015
Couple 2: Map - nu: 0.00015
Couple 3: Map - nu: 0.0015
Couple 4: Map - nu: 0.0015
Couple 5: Map - nu:-0.0018
Couple 6: Map - nu:-0.0018

Output: Node: 1
Propag: 2
	\end{lstlisting}
\end{center}
\caption{An example configuration file, which can be found in \type{Configs/cortex.conf}.}
\end{figure}

In general, the entries in configuration file follow the following rules:

\begin{enumerate}
	\item Each entry generally follows a \type{Pamameter: value} pattern.
	\item Most parameters are essential. Failure to provide these parameters would result in \type{NeuroField} terminating with an error message. A minority of the parameters are optional.
	\item The ordering of the parameters are important. Wrong parameter ordering results in \type{NeuroField} terminating with an error message.
	\item With the exception of keywords, the configuration file is white-space independent, e.g., there can be either no spaces, many spaces, or new lines between the colon of \type{Integration steps: 10000} and 10000, but you cannot have two spaces between \type{Integration} and \type{steps}. For consistency and readability, users are encouraged to follow the existing white space scheme when reasonable.
	\item Tip for \type{vi} users: \type{./helper\_scripts/neurofield.vim} implements syntax highlighting for configuration files in \type{vi}. See comments within for installation instructions.
\end{enumerate}

\subsubsection{Global information}
\label{sec:global}
\begin{itemize}

\item
\begin{lstlisting}
Purely cortical model with excitatory and inhibitory neurons
\end{lstlisting}
Any text before the entry, \type{Integration steps:}, is disregarded by \type{NeuroField} and serves as comment.
\item
\begin{lstlisting}
Prvious steps: 0 Integration steps: 10000 Output onset: 0 Deltat: .0001 
\end{lstlisting}
\type{Previous steps} is an optional parameter generated by \type{NeuroField} for restart mode. Users should not touch this unless they know what they are doing.

\type{Integration steps} is the number of steps the code should step forward during the run.

\type{Output onset} is an optional parameter of how many integration steps should be skipped before output commenses.

\type{Deltat} is the time increment for each time step.
\item
\begin{lstlisting}
Nodes: 4 Longside: 2
\end{lstlisting}
\type{Nodes} is the number of grid points in the spatial dimension per population of neurons. The code has been explicitly designed to have equal number of neurons per population.

\type{Longside} is an optional parameter, specifying the longside of the rectangular grid. If it is not supplied, it is assumed to be a square.

Both spatial dimensions have periodic boundary conditions, so that populations have the topology of a torus.
\item
\begin{lstlisting}
Glutamate dynamics - Lambda: 3e-4 tGlu: 5e-3
\end{lstlisting}
Parameters governing glutamate dynamics, which is currently useful only for \type{CaDP} couples.

\type{Lambda} is the glutamate release concentration per presynaptic spike, in moles.

\type{tGlu} is the decay timescale of glutamate in seconds.
\item
\begin{lstlisting}
Connection matrix:
From: 1 2 3 4
To 1: 0 0 0 0
To 2: 0 0 0 0
To 3: 1 0 2 3
To 4: 0 4 5 6
\end{lstlisting}
We specify an arbitrarily sized square connection matrix, where each entry is the connection from the column population to the row population.

Zero indicates no connection.

A nonzero number indicates connection. This number must be indexed from top to bottom, left to right.
\end{itemize}

\subsubsection{Population data}
\label{sec:pop}
This section contains population information sections. There are two types of neural populations: ordinary populations and stimulus populations:
\begin{description}

\item[Stimulus populations]\ \\

\type{NeuroField} identifies stimulus populations as populations which have no dendrites, i.e., the row for that population contains no nonzero elements.  Each stimulus population information section is as follows.
\begin{itemize}
	\item \begin{lstlisting}
Population 1: Stimulation
	\end{lstlisting}
	The identifier \type{Population 1} is required for cross-checking.

	The descriptor \type{Stimulation} is not parsed by \type{NeuroField}, but it is strongly recommended for human referencing.
	\item
	\begin{lstlisting}
Stimulus: Mode: Const - Onset: 0.0002
	\end{lstlisting}
	The identifier \type{Stimulus} is required for cross-checking.

	\type{Onset} specifies the time onset before the stimulus begins. Users should allow at least two timesteps for the transient state before onset.

	\type{Mode} specifies the stimulus mode, which includes, for example:

	Pulse stimulus pattern:
	\begin{lstlisting}
Mode: Const - Amplitude: 20 Width: 0.02 Repetition: 1
	\end{lstlisting}

	White noise stimulus pattern (spatially uncorrelated), where Ranseed
is an optional parameter for the random number generator's initial seed defaulting to -98716872:
	\begin{lstlisting}
Mode: White - Ranseed:-98716872 Amplitude: 20
	\end{lstlisting}

	A ``special" stimulus pattern is the composite pattern. At onset (encouraged to be set to zero), it superimposes an arbitrary number of stimuli:
	\begin{lstlisting}
Stimulus: Mode: Composite - Onset: 0 Number of Stimuli: 2
 Mode: MNS - Onset: 0.5
  N20 width: .01 N20 height: 7 P25 width: .01 P25 height: 18
 Mode: Pulse - Onset: 0.53 Amplitude: 18 Width: 4e-3
	\end{lstlisting}

	\end{itemize}
\item[Ordinary populations]\ \\
	Any non-stimulus population is an ordinary population.

	\begin{itemize}
	\item
	\begin{lstlisting}
Population 3: Excitory neurons
	\end{lstlisting}
	The identifier \type{Population 3} is required for cross-checking.
	
	The descriptor \type{Excitatory neurons} is not parsed by \type{NeuroField}, but it is strongly recommended for human referencing.
	\item
	\begin{lstlisting}
Q: 8.87145
	\end{lstlisting}
	The initial firing rate.
	\item
	\begin{lstlisting}
Firing: Sigmoid - Theta: 0.013 Sigma: 0.0038 Qmax: 340.0
	\end{lstlisting}
	Specify the sigmoidal firing response of the population.

	\type{Sigma} is sometimes known as \(\tilde{\sigma}\). It is already scaled by \(\pi/\sqrt{3}\).

	Alternatively, you can specify a linear firing response by using
	\begin{lstlisting}
Firing: Linear - Gradient: 1 Intercept: 1
	\end{lstlisting}

	\item
	\begin{lstlisting}
Dendrite 1: V: Steady alpha: 83 beta: 769
	\end{lstlisting}
	The identifier \type{Dendrite 1}, where 1 is the presynaptic connection index, is required for cross-checking. Users should find that these indices are simply ordered as 1, 2, 3, 4, ...
	
	\type{V} is the initial depolarization contribution from presynaptic activity. It can be a numerical value with units of V, or set at \type{Steady}, so that \type{NeuroField} calculates the initial value by \(V_{ab}=\nu_{ab}\phi_{ab}\).

	\type{alpha} and \type{beta} are the parameters for the depolarization response.
	\end{itemize}
\end{description}

\subsubsection{Propagation data}
\label{sec:prop}
\item
	\begin{lstlisting}
Propag 1:
	\end{lstlisting}
	This identifier is required for cross-checking.
\item A propagator type is required at this point. Choices are \type{Map}, \type{Wave}, \type{Harmonic}, and \type{Patchy}.
\begin{description}
	\item[Map]\ \\
	\begin{lstlisting}
Map - Tau: 0
	\end{lstlisting}
	This propagator is the mapping propagator where spatial spreading is negligible. Its form is given by
	\[\phi_{ab}({\bf r}, t) = Q_b ({\bf r}, t - \tau_{ab}).\]
	Its only one parameter, \type{Tau}, is the the delay term. It is specified below.

	\item[Wave]\ \\
	This propagator is the wave equation propagator governed by the equation
	\[\left[\frac{1}{\gamma_{ab}^2}\frac{d^2}{d t^2}+\frac{2}{\gamma_{ab}}\frac{d} {d t}+1 \right] \phi_{ab}({\bf r},t) =Q_b({\bf r},t-\tau_{ab}).\]
	Its input is given by
	\begin{lstlisting}
Wave - phi: Steady Deltax: 0.0035 Tau: 0 Range: 0.08 gamma: 116
	\end{lstlisting}
	\type{phi} is the initial value for $\phi_{ab}$ in the wave equation. Inputting \type{Steady} gives \(\phi_{ab} = Q_b\).

	\type{Deltax} is the length of a node in mm. This must satisfy the Courant condition, \[\Delta t/\Delta x<\sqrt{2}/r_e\gamma_e.\]

	\type{Range} is $r_{ab}$ in the wave equation.
	
	The final parameter can be \type{gamma} or \type{velocity} in the wave equation.

	\item[Harmonic]
	This is a harmonic oscillator implementation of the damped wave equation. If there is no spatial variation, use \type{Harmonic} instead of \type{WaveEqn}.
	The input form is given by 
	\begin{lstlisting}
Harmonic - phi: Steady Tau: 0 gamma: 116
	\end{lstlisting}

	\item[Patchy]
	This is the Robinson patchy propagator. It has not been currently tested.

	\item[Tau]\ \\
	The axonal time delay between populations. If it is spatially homogeneous, then it is a number with units of seconds. If it is spatially inhomogeneous, then input \(n\) numbers, where \(n=\) \type{Nodes}.

\end{description}

\subsubsection{Coupling data}
\label{sec:couple}

\begin{itemize}

	\item
	\begin{lstlisting}
Couple 1:
	\end{lstlisting}
	Identifier for cross-checking.
	\item A couple type is required at this point. Choices are \type{Map}, \type{Modcouple}, and \type{CaDP}.

\begin{description}

	\item[Map]\ \\
	Nonplastic synaptic coupling wtih a single constant parameter \type{nu},
	\begin{lstlisting}
Map - nu: 0.0012
	\end{lstlisting}
	\type{nu} is the synaptic coupling parameter. It corresponds to the product of the mean synaptic strength $s_{ab}$ and $N_{ab}$, the mean number of connections from cells of type $b$ to cells of type $a$.

	\item[Modcouple]\ \\
	The modulated synaptic coupling implements the Clearwater/Rennie modulation equation. The modulation is given by
	\[ \nu (t) = \nu_0 \left[ ( 1 - \nu_{scal} ) e^{h(t)/k} + \nu_{scal} \right], \]
	where $h(t)$ is the time low passed filtered form of the neuromodulators concentration $C(t)$ as given by
	\[
	\left\{ \frac{1}{\mu \lambda} \frac{d^2}{dt^2} +
	\left[ \frac{1}{\nu}+ \frac{1}{\lambda} 
	\right]
	\frac{d}{dt} + 1
	\right\}
	h(t) = C(t).
	\]
	The neuromodulator's concentration is in turn given by a user chosen stimulus form analogous to stimulus populations.

	The remainder of the input form is specification of the output for $\nu$.  This takes an analogous form to the usual output data lines. The $\nu$ data is output to a file with filename \type{neurofield.synaptout.xx} where xx is an index number of the coupling.

	An example Modcouple input form is given by
	\begin{lstlisting}
ModCouple - Nuzero: 0.0002 Nuscal: 0.02 Mu: .1 Lambda: 1 k: .000001
Concentration mode: 1  Time to start of Concentration: .01 Amplitude: .0001
Pulse Duration: .2 Pulse repetition period: 40
Number of traces: 100  Single/All: All nodes}
	\end{lstlisting}

	\item[CaDP]\ \\
	Calcium dependent plasticity according to Fung and Robinson.
	\begin{lstlisting}
CaDP - nu: .4086e-4 Nu_max: .1e-3 Threshold: 1e-4 LTD: 5e-2 LTP: 8e-2 B: 2e4 N: 10000 rho: 4200
	\end{lstlisting}

\end{description}
\end{itemize}

\subsubsection{Output data}
\label{sec:output}

\type{NeuroField} can output a time series for arbitrary fields on any particular nodes, into an output file named \type{neurofield.output} by default. A user chooses which objects to output, and on which nodes to output on. The object then outputs the field(s). For example, populations output $V_a$, propagators output $\phi_{ab}$, and couples output $\nu_{ab}$, and they may output additional fields if appropriate.

An example output is
\begin{lstlisting}
                Time  |          Propag.2.phi
                      |                     0
1.00000000000000e-04  |  8.87145000000000e+00
\end{lstlisting}

Each column is a time series with its name indicated in the first line. The first column is always time, and in this example, the second column is \type{Propag.2.phi}, indicating that it is $\phi_{ee}$ (when checked against connection matrix). The delimiter \type{|} indicates that the two columns are different fields, rather than different nodes of the same field. The node number is indicated in the second line.

To specify output in the configuration file, we start by 
\begin{itemize}
	\item
	\begin{lstlisting}
Output: Node: 1 Start: 0 Interval: .0002
	\end{lstlisting}
	We first specify which nodes to output. \type{Node: All} is a shorthand to output all nodes.

	\type{Start} is the time in seconds to start outputting. If this is not given, then output starts at time 0.

	\type{Interval} is the time interval in seconds between each output. If this is not given, then \type{NeuroField} outputs every timestep.

\item
	\begin{lstlisting}
Population: 3
Propag: 2
Couple: 2
	\end{lstlisting}
	Specify an arbitrary number of objects to output.

\end{itemize}

\subsection{Postprocessing}

\type{NeuroField} produces 3 files:

\begin{tabular}{l p{11.5cm}}
\type{neurofield.conf}& When using the launcher script, this file is created to store the running configuration file.\\
\type{neurofield.dump}& \type{NeuroField} dumps data here when it terminates. This file can be used in restart mode to continue simulation (see Sec.~\ref{sec:exe}). Creation of this file can be suppressed by a \type{-s} or \type{--silent} switch.\\
\type{neurofield.output}& The result of the simulation is stored here for postprocessing.\\
\type{neurofield.pbs}& If \type{NeuroField} is run in \type{yossarian}, then this file stores the output of the queueing system.
\end{tabular}

When evoked directly, the \type{Release/NeuroField} executable creates the output file in the present working directory. When the launcher script runs with only one set of parameters, all output files are also in the present working directory. However, if the launcher script sweeps over parameters, each parameter set has its own subdirectory inside \type{Output/}, and each set of \type{neurofield.*} files are stored in its subdirectory.

These output files may be further processed by helper scripts and plotting routines located in \type{helper\_scripts/}\footnote{A source that wishes to remain unidentified testifies that the \type{helper\_scripts/} directory is in a state of chaos; the source advises users to write and use their own scripts.}.

\pagebreak
\section{Developers guide}

\type{NeuroField} is coded in \type{ANSI C++}. This guide assumes readers have basic knowledge of \type{C++}, including object oriented programming, usage of template, and standard template library (STL). An \type{OpenMP} version of the code exists for running on multicore machines. It scales sublinearly.

\type{NeuroField} solves each equation within the Robinson et al. model with an object:
\begin{align*}
	D_{ab}V_{ab}(\mathbf{r},t) &= \nu_{ab}\phi_{ab}(\mathbf{r},t), & \mathrm{Dendrite}\\
					  Q_a(\mathbf{r},t) &= S_a \big[\sum_b V_{ab}(\mathbf{r},t) \big], & \mathrm{QResponse}\\
	\mathcal{D}_{ab}\phi_{ab}(\mathbf{r},t) &= Q_b(\mathbf{r},t-\tau_{ab}).&  \mathrm{Propag}
\end{align*}
\type{Propag} and \type{Couple} is overloaded to give more sophisticated axonal propagation (see Sec.~\ref{sec:propag}) and synaptic plasticity (see Sec.~\ref{sec:couple}), respectively.

\subsection{Coding style}

Within the C++ source files, developers should stick to this conventions for consistency:

\begin{tabular}{ l l }
	Tabs:& two spaces.\\
	Braces:& the K\&R style is strongly encouraged.\\
	Class names:&UpperCamelCase\\
	Function names:&lowerCamelCase\\
	Variable names:&lowercase
\end{tabular}

\subsection{Class diagram}

\begin{figure}[h!]\begin{center}
\tikzstyle{block} = [draw,text width=8em,text centered,minimum height=4em]
\tikzstyle{line} = [draw, -latex']
    
\begin{tikzpicture}[node distance = 3em, auto]
	\node[] (solver) {\type{Solver}};
    \node[below of=solver,node distance=3em] (vsolver) {};
    \draw (solver) |- (vsolver);

	\node[left of=vsolver,node distance=5em] (vpropag) {};
    \draw (vsolver) -- (vpropag);
	\node[left of=vpropag,node distance=10em] (vpop) {};
    \draw (vpropag) -- (vpop);
	\node[right of=vsolver,node distance=5em] (vcouple) {};
    \draw (vsolver) -- (vcouple);
	\node[right of=vcouple,node distance=10em] (voutput) {};
    \draw (vcouple) -- (voutput);

	\node[below of=vpropag] (apropag) {\type{Array$\langle$Propag$\rangle$}};
    \draw (vpropag) -| (apropag);
	\node[below of=vpop]    (apop) {\type{Array$\langle$Population$\rangle$}};
    \draw (vpop) -| (apop);
	\node[below of=vcouple] (acouple) {\type{Array$\langle$Couple$\rangle$}};
    \draw (vcouple) -| (acouple);
	\node[below of=voutput] (aoutput) {\type{Array$\langle$Output$\rangle$}};
    \draw (voutput) -- (aoutput);

	\node[below of=apropag] (propag) {\type{Propag} $\ni \phi_{ab}$};
    \draw (apropag) -- (propag);
	\node[below of=apop]    (pop) {\type{Population} $\ni Q_a$};
    \draw (apop) -- (pop);
	\node[below of=acouple] (couple) {\type{Couple} $\ni \nu_{ab}$};
    \draw (acouple) -- (couple);
	\node[below of=aoutput] (output) {\type{Output}};
    \draw (aoutput) -- (output);

	\node[below of=pop,node distance=3em](vpop){};
    \draw (pop) |- (vpop);
	\node[left of=vpop,node distance=4em](vs){};
    \draw (vpop) |- (vs);
	\node[right of=vpop,node distance=4em](vq){};
    \draw (vpop) |- (vq);

	\node[below of=vs,node distance=3em](s){\type{Timeseries}};
    \draw (vs) -- (s);
	\node[below of=vq,node distance=3em](q){\type{QResponse} $\ni V_a$};
    \draw (vq) -- (q);

	\node[below of=q](adendrite){\type{Array$\langle$Dendrite$\rangle$}};
    \draw (q) -- (adendrite);
	\node[below of=adendrite](dendrite){\type{Dendrite} $\ni V_{ab}$};
    \draw (adendrite) -- (dendrite);

	\node[below of=propag,node distance=3em](tau){\type{Tau} $\ni \tau_{ab}$};
	\draw(propag)--(tau);
\end{tikzpicture}
\caption{Schematic of the main class structures in \type{NeuroField}. Each line indicates that the bottom class is a member of the top class. The \type{a} $\ni b$ symbol indicates that the dynamical field $b(\mathbf{r},t)$ is a member of the class \type{a}. Inheritance structures are NOT illustrated.}
\label{fig:class}\end{center}\end{figure}

%\begin{figure}[h!]\begin{center}\includegraphics[scale=.8]{class.pdf}\caption{}\end{center}\end{figure}

\subsection{Class NF}
\label{sec:nf}

\textbf{ALL} classes (with the exceptions being \type{Configf} and \type{Dumpf}) should derive from the \type{NF} object. This abstract base class contains 3 member variables, and 4 interface methods:

\begin{tabular}{l p{10cm}}
Variable\\[6pt]
\type{nodes}&The number of nodes as specified from the configuration file.\\
\type{deltat}&The time increment per timestep in units of seconds.\\
\type{index}&The index associated with the object.\\[6pt]
Methods\\[6pt]
\type{init(Configf\& configf)}&Initializes the object with the config file.\\
 \type{dump(Dumpf\& dumpf) const}&When the program terminates, all objects dump information into a dump file (\type{dumpf}) for later restart. \type{Dumpf} is an \type{ofstream}.\\
\type{restart(Restartf\& restartf)}&Restarts the object in restart mode, \emph{in addition} to \type{init()}. The developer should have dumped all relevant information in dump, then reads it here.\\
\type{step(void)}&At each timestep, this function is called.\\
\end{tabular}

All \type{NF} classes automatically handles the \type{ofstream::<<} and \type{ifstream::>>} operators.

\subsection{Class Array}
\label{sec:array}

\type{Array} is a container array to store objects that supports the \type{ofstream::<<} and \type{ifstream::>>} operators, as well as a \type{step(void)} function. This object typically is, but not necessarily has to be an \type{NF} object.

The \type{step(void)} function is equivalent to a \type{foreach(element).step()} in pseudocode. This function is encouraged over the use of \type{empty()}, \type{size()}, and \type{operator[]()}, which are discouraged to be used.

\subsection{Input/Output}

Input via the configuration file is implemented in the \type{init()} function, via \type{Configf}, which provides the following functions:
	\begin{enumerate}
	\item next: go to the next keyword
	\item param: go to the next keyword and reads in a variable. If the keyword is not found, barks and exits.
	\item optional: same as param, but does not bark nor exit.
	\item find: search a keyword and return the next variable as string.
	\end{enumerate}

In restart mode, \type{init()} is called, followed by \type{restart()}. \type{Restartf} is identical to \type{Configf}.

There are two modes of output. One is outputting the solution in \type{Population::output(), \type{Propag::output()}}, and \type{Couple::output()}, and the other is the dumping of data for restart implemented in \type{dump()}.

To output solutions, return a vector of pointers to \type{new Output}, specifying the name and field of the solution. The name must be of the format
\begin{lstlisting}
label("Object.",index+1)+".field"
\end{lstlisting}
where \type{Object} and \type{field} should be appropriately named.

\type{dumpf()} provides a \type{Dumpf} object, which is essentially an \type{ofstream}. Dump all data here, so that it can be read in \type{restart()}.

\subsection{Writing a new class}

In extending \type{NeuroField} it is likely new classes needs to be written. When doing this, it would be useful to keep in mind:
\begin{enumerate}
	\item When appropriate, the default constructor, copy constructor, and \type{operator=} should be made inaccessible by declaring them to be private.
	\item The \type{NF} class \textbf{MUST} be inherited.
	\item The \type{init()}, \type{restart()}, \type{dump()}, \type{step()} functions should be overloaded appropriately. Keep in mind that \type{restart()} internally calls \type{init()} at the beginning.
	\item \type{Population}, \type{Propag}, and \type{Couple} has the \type{output()} function to specify which field(s) to output. Overload this if appropriate.
	\item When in doubt, read existing class implementations for examples.
\end{enumerate}

\subsubsection{Class Population}
\label{sec:pop}

Models a neural population, which may be either a stimulus or normal population. If it has any dendrites, i.e. it has presynaptic connections, then it is a normal population, and it is a stimulus if it does not have dendrites.

In the former case, it contains the \type{QResponse} class and have a soma potential; in the latter case it contains the \type{Timeseries} class, and does not have a soma potential. See Fig.~\ref{fig:class} for reference.

In either cases, the \type{Population} class has a keyring storing the firing rate history, coded as a 2D array plus an integer key.

A population is ``settled" after \type{Population::init()} is called, after which no dendrites can be added, and the firing rate history cannot grow.

\subsubsection{Class Propag}
\label{sec:propag}

The \type{Propag} class implements the axonal propagation as an identity map, i.e.
\[ \mathcal{D}_{ab} = 1. \]

To introduce more sophisticated axonal propagation, this class is inherited and overloaded.

The \type{Propag} class provides a constant pointer to both presynaptic and postsynaptic populations.

\subsubsection{Class Couple}
\label{sec:couple}

The \type{Couple} class manages \(\nu_{ab}\), which is constant in space and time.

To introduce synaptic plasticity, derive from this class.

The \type{Couple} class provides a constant pointer to both presynaptic and postsynaptic populations. Glutamate concentration is also provided. \type{pos} is $+1$ or $-1$, depending on the sign of \(\nu_{ab}\).

\subsection{Program flow}

Essentially, the program flow can be read from Fig.~\ref{fig:class}, so that objects take priority from top to bottom, left to right, both in terms of initialization and stepping through each timestep. A more detailed description is given below, and the reader is referred to the source code for complete description.

We use the semicolon to denote a succession of functions/procedures, and \type{a()} $\Rightarrow$ \type{b()} symbol to denote function \type{b()} as content of function \type{a()}.

\begin{center}
\begin{tabular}{ | l l p{11cm} | }
\hline \\

\type{main()}& $\Rightarrow$ &Initialize the config file, dump file and output file;\\[6pt]
&&\type{Solver::init()};\type{Solver::solve()};\\[6pt]
\type{Solver::init()}& $\Rightarrow$ &read in global parameters; Read in \type{CntMat};\\[6pt]
&&Construct \type{Population}; construct \type{Propag}; construct \type{Couple}; \type{Population::add2Dendrite()};\\[6pt]
&&Read configurations for \type{Population}, \type{Propag}, \type{Couple}, and \type{Output}.\\[6pt]
\type{Solver::solve()}& $\Rightarrow$ & \type{for(...) \{ Solver::step(); \type{Output::step()}; \} }\\[6pt]
\type{Solver::step()}& $\Rightarrow$ & \type{Population::step()}; \type{Propag::step()}; \type{Couple::step()};\\[6pt]
\type{Population::step()}& $\Rightarrow$ & \type{QResponse::step()} if neural population;\\[6pt]
&&\type{Timeseries::step()} if stimulus\\[6pt]
\type{QResponse::step()}& $\Rightarrow$ & \type{Dendrite::step()}; sum over \(V_{ab}\)

\\\hline
\end{tabular}
\end{center}

\begin{itemize}
\item One integration step of the model implements the following stages: 1) Dendritic response 2) Afferent summation. 3) Firing response/stimulus response. 4) Wave equation integration step which includes Q delay processing 5) Coupling response.
\item Most of the computational load comes from integrating wave equations and harmonic oscillators within the dendritic responses.
\item Wave equations are integrated by explicit finite differences integration. A nine point spatial stencil is used to reduce high frequency spatial instabilities when driven by random noise. Other parts of code are unaffected by spatial geometry so this can be switched to irregular gridding easily.
\item Harmonic oscillators with dendritic rseponse are integrated using a heavily strength reduced explicit direct integration assuming constant drive. This was more efficient than a constant drive RK4 algorithm which would not be fourth order in any case due to the constant drive. Rennie used a constant drive RK4 for his 1997 code.
\end{itemize}

\subsection{Other classes}

\begin{description}
\item[CaDP] A coupling class implementing calcium dependent plasticity.
\item[Dendrite] Manages dendritic responses.
%\item[Eqnset] A class to provide the ``Eqnset"---multiple wave equations form of the propagator. This feature has not had significant testing. It uses the helper classes Prefact, Field and Weqn.
%\item[Field] A helper class to hold Phi field information for waveeqn and Eqnset (via Weqn).
%\item[Modcouple] A class which provides synaptic coupling following a model proposed by Clearwater-Rennie for modelling neurotransmitter dynamics.
%\item[Pharmonic] A class to provide the ``Harmonic"---harmonic oscillator behaviour propagator. This si typically used for spatially uniform simulations as it is more efficient than a wave equation propagtor where the simulation will have no spatial variation.
%\item[Pmap] A class to provide the ``Mapping" propagator behaviour.
%\item[Prefact] A helper class for Eqnset to calculate some prefactors used in the calculations of Eqnset.
\item[QResponse] Manages Dendrites, finds the soma potential and calculates the neural firing response.
\item[Random] Generates random numbers for Timeseries.
\item[Solver] Encapsulates the entire \type{NeuroField} program.
%\item[STDP] A coupling class implementing linear STDP plasticity.
\item[Tau] Stores the axonal time delay \(\tau_{ab}\), which can be spatially homogeneous or inhomogeneous. Belongs to Propag, but used by Population.
\item[Timeseries] Generated time series for stimulus input and other driven processes such as time modulated coupling strengths.
%\item[Weqn] A helper class for propagators to store information about Tau, the axonal delays associated wtih propagators.
\end{description}

\subsection{Submission to SVN}
The SVN repository is a standard installation, so any tutorials on usage of SVN apply here. For developers, we suggest obtaining a copy of the entire repository with

\begin{lstlisting}
svn co http://silliac.physics.usyd.edu.au:18080/svn/neurofield/ neurofield --username=<your SVN username>
\end{lstlisting}
	
The following folders are present:

\begin{tabular}{l p{12cm}}
\type{branches}& Folders for users to make changes to the program.\\
\type{tags}& Previous versions of the program.\\
\type{trunk}& Latest stable version of the program.\\
\end{tabular}

To make changes to the program, it is recommended to copy the trunk into a new subfolder within branches

\begin{lstlisting}
cp -r trunk ./branches/my_branch
\end{lstlisting}
	
You can then freely modify the code in the branch with the benefit of version control, and other users can obtain your code through the branch. If your modifications are accepted for the main program, your branch will then be merged into the trunk subject to appropriate testing.

\subsection{TODO}
\begin{enumerate}
\item optional initial V and phi, correct the steady implementation.
\item check numerical entry of connection matrix
\item implement nontrivial propagators
\item tidy up helper scripts
\item restart mode is crippled; rewrite the whole thing.
\item implement restart mode in launcher script
\end{enumerate}
\end{document}
